#!/usr/bin/env node

var hyperstream = require('..')
var minimist = require('minimist')
var low = require('last-one-wins') 

var opts = minimist(process.argv.slice(2))

if (opts.help || process.argv.length === 2) {
  console.log('\nDecentralized secure binary streaming, powered by hyperdb\n')
  
  console.log('  --storage path            save database to path')
  console.log('  --key key                 database to use')
  console.log('  --info                    output database info')
  console.log('  --sync                    connect to a peer and synchronize with them')
  console.log('  --serve                   stay alive, communicating with peers')
  console.log('  --pipe [key]              publicize from stdin and/or write key to stdout')
  console.log('  --start offset            rewind stream to offset before output')
  console.log('')

  process.exit(0)
}

var storage = opts.storage || require('random-access-memory')
var key = opts.key && Buffer.from(opts.key, 'base64')

var hs = hyperstream(storage, key)
hs.ready(ready)

var sw = null
var outstream = null

function ready() {

  if (!opts.storage && !opts.key) {
    opts.info = true
    opts.serve = true
    console.log('Generated an in-memory database.')
  }

  if (opts.sync || opts.serve) {
    sw = require('hyperdiscovery')(hs.db)
  }

  if (opts.info) {
    console.log('Database: ' + hs.db.key.toString('base64'))
    console.log('User: ' + hs.db.local.key.toString('base64'))

    if (opts.verbose) {
      hs.db.on('remote-update', function(feed, id) { console.log('DB: remote-update ' + feed.key.toString('base64') + ' #' + id) })
      hs.db.on('append', function(feed, id) { console.log('DB: append ' + feed.key.toString('base64') + ' #' + id) })
    }

    if (sw) {
      if (opts.verbose) {
        sw.on('close', function() { console.log('NET: close') })
        sw.on('peer', function(peer) { console.log('NET: peer ' + peer.id) })
        sw.on('drop', function(peer) { console.log('NET: drop ' + peer.id) })
        sw.on('connecting', function(next) { console.log('NET: connecting ' + next.id) })
        sw.on('connection', function(connection, info) { console.log('NET: connection ' + connection.key.toString('base64') + ' (' + info.type +')') })
        sw.on('error', function(err) { console.log('NET: error ' + err) })
        sw.on('listening', function() { console.log('NET: listening') })
      }
    }
  }

  if (opts.sync) {
    hs.db.once('remote-update', main)
  } else {
    main()
  }
}

function main() {
  if (opts.info) {
    var streams = hs.getStreams()
    console.log(streams.length + ' Streams:')
    for (var i = 0; i < streams.length; ++ i)
      console.log('  ' + streams[i])
  }
  if (opts.pipe) {
    process.stdin.pipe(hs.createWriteStream())
    if (opts.pipe === true) {
      process.stdin.on('end', finish)
    } else {
      pipeout(opts.pipe, finish)
    }
  }
  if (sw && !opts.serve && !opts.pipe) {
    finish()
  }
}

function pipeout (key, cb) {
  outstream = hs.getStream(key, function () {
    var checkpoints = outstream.checkpoints({'reverse': true})
    var end = 0
    var nextend = null
    var start = 0
    var keepStreaming = false
    checkpoints.next(seekValid)
  
    function seekValid (err, checkpoint) {
      if (err) return cb(err)
      if (checkpoint === null) return startStreaming()
      outstream.verify(checkpoint, function(err) {
        if (err) {
          console.error(err)
          return checkpoints.next(seekValid)
        } else {
          end = checkpoint.byteLength
          startStreaming()
        }
      })
    }
  
    var writeout = low(function(length, cb2) {
      outstream.read(start, length, {}, function (err, data) {
        if (err) return cb(err)
        process.stdout.write(data)
        start += data.length
        cb2()
      })
    })

    function startStreaming() {
      keepStreaming = true
      if (opts.start === undefined)
        opts.start = end
      start = opts.start
      if (start > end) {
        return cb(new Error('start offset is past end of verified stream'))
      }
      if (nextend) {
        end = nextend
        nextend = null
      }
      if (end != start) writeout(end - start)
    }
  
    outstream.listen()
    outstream.on('checkpoint', function (checkpoint) {
      if (checkpoint.byteLength <= end) return console.error('checkpoint fails to advance')
      outstream.verify(checkpoint, function(err) {
        if (err) return console.error(err)
        if (!keepStreaming) {
          console.error('Warning: found new valid data before finding validated previous tail')
          nextend = checkpoint.byteLength
        } else {
          end = checkpoint.byteLength
          if (end != start) writeout(end - start)
        }
      })
    })
  })
}

function finish (err) {
  if (err) console.error(err)
  if (outstream) outstream.ignore()
  sw.close()
}
