#!/usr/bin/env node

var hyperstream = require('..')
var minimist = require('minimist')
var low = require('last-one-wins') 

var opts = minimist(process.argv.slice(2))

if (opts.help || process.argv.length === 2) {
  console.log('\nDecentralized secure binary streaming, powered by hyperdb\n')
  
  console.log('  --storage path            save database to path')
  console.log('  --db key                  database to use')
  console.log('  --quiet                   do not output anything')
  console.log('  --info                    output database info (default when not piping out)')
  console.log('  --sync                    sync with a network peer before doing anything else')
  console.log('  --serve                   connect to the network and communicate until terminated')
  console.log('  --authorize [key]         publicize a user\'s stream')
  console.log('  --pipe [key]              publicize from stdin and/or write key to stdout')
  console.log('  --start offset            rewind stream to offset before output')
  console.log('')

  process.exit(0)
}

var storage = opts.storage || require('random-access-memory')
var key = opts.db && Buffer.from(opts.db, 'base64')

var hs = hyperstream(storage, key)
hs.ready(ready)

var sw = null
var outstream = null

function ready() {

  if (!opts.pipe || opts.pipe === true) {
    if (!opts.quiet)
      opts.info = true
  }
  if (!opts.storage && !opts.db) {
    opts.serve = true
  }
  if (opts.info && !opts.storage) {
    console.log('Generated an in-memory database.')
  }

  if (opts.sync || opts.serve) {
    sw = require('hyperdiscovery')(hs.db)
  }

  if (opts.info) {
    console.log('Database: ' + hs.db.key.toString('base64'))
    console.log('User: ' + hs.db.local.key.toString('base64'))

    if (opts.verbose) {
      hs.db.on('remote-update', function(feed, id) { console.log('DB: remote-update ' + feed.key.toString('base64') + ' #' + id) })
      hs.db.on('append', function(feed, id) { console.log('DB: append ' + feed.key.toString('base64') + ' #' + id) })
    }

    if (sw) {
      if (opts.verbose) {
        sw.on('close', function() { console.log('NET: close') })
        sw.on('peer', function(peer) { console.log('NET: peer ' + peer.id) })
        sw.on('drop', function(peer) { console.log('NET: drop ' + peer.id) })
        sw.on('connecting', function(next) { console.log('NET: connecting ' + next.id) })
        sw.on('connection', function(connection, info) { console.log('NET: connection ' + connection.key.toString('base64') + ' (' + info.type +')') })
        sw.on('error', function(err) { console.log('NET: error ' + err) })
        sw.on('listening', function() { console.log('NET: listening') })
      }
    }
  }

  if (opts.sync) {
    hs.db.once('remote-update', function() { main() })
  } else {
    main()
  }
}

function main(err) {
  if (err) console.error(err)
  if (opts.authorize) {
    var authorizee = opts.authorize
    opts.authorize = null
    return hs.db.authorize(Buffer.from(authorizee, 'base64'), main)
  }
  if (opts.info) {
    var streams = hs.getStreams()
    console.log(streams.length + ' Streams:')
    for (var i = 0; i < streams.length; ++ i)
      console.log('  ' + streams[i])
  }
  if (opts.pipe) {
    process.stdin.pipe(hs.createWriteStream())
    process.stdin.on('end', finish)
    if (opts.pipe !== true) {
      pipeout(opts.pipe, finish)
    }
  }
  if (sw && !opts.serve && !opts.pipe) {
    finish()
  }
}

function pipeout (key, cb) {
  outstream = hs.getStream(key, function (err) {
    if (err) return finish(err)
    var checkpoints = outstream.checkpoints({'reverse': true})
    var end = 0
    var nextend = null
    var start = 0
    var keepStreaming = false
    checkpoints.next(seekValid)
  
    function seekValid (err, checkpoint) {
      if (err) return cb(err)
      if (checkpoint === null) return startStreaming()
      outstream.verify(checkpoint, function(err) {
        if (err) {
          console.error(err)
          return checkpoints.next(seekValid)
        } else {
          end = checkpoint.byteLength
          startStreaming()
        }
      })
    }
  
    var writeout = low(function(length, cb2) {
      outstream.read(start, length, {}, function (err, data) {
        if (err) return cb(err)
        process.stdout.write(data)
        start += data.length
        cb2()
      })
    })

    function startStreaming() {
      keepStreaming = true
      if (opts.start === undefined)
        opts.start = end
      start = opts.start
      if (start > end) {
        return cb(new Error('start offset is past end of verified stream'))
      }
      if (nextend) {
        end = nextend
        nextend = null
      }
      if (end != start) writeout(end - start)
    }
  
    outstream.listen()
    outstream.on('checkpoint', function (checkpoint) {
      if (checkpoint.byteLength <= end) return console.error('checkpoint fails to advance')
      outstream.verify(checkpoint, function(err) {
        if (err) return console.error(err)
        if (!keepStreaming) {
          console.error('Warning: found new valid data before finding validated previous tail')
          nextend = checkpoint.byteLength
        } else {
          end = checkpoint.byteLength
          if (end != start) writeout(end - start)
        }
      })
    })
  })
}

function finish (err) {
  if (err) console.error(err)
  if (outstream && outstream.listening()) outstream.ignore()
  if (sw) sw.close()
}
